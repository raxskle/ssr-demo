# SSR 项目 demo

基于 Node, koa 部署一个处理 CGI 和 SSR 的服务

纯浏览器渲染存在的问题：

1. 浏览器承担执行 JS，渲染页面，请求数据等一系列工作， 会占用浏览器更多的运行内存，导致浏览器变卡。
2. 服务端返回的是空的 HTML，不利于 SEO
3. 浏览器拿到 html 后才请求下载 JS, CSS, IMG 等资源，然后在执行脚本生成页面，造成了一定的白屏时间，降低用户体验。
   服务端渲染有更好的 SEO，更快的内容到达时间 (time-to-content)的优点，为解决浏览器渲染提供了一个好的方案。

## 链路

用户请求 ---> 服务器解析路由找到对应的组件 --> 通过 Renderer 渲染成 HTML 字符串并发送给客户端 ---> 客户端解析 HTML 并加载必要的 JS 文件 ---> 执行 Js 对页面进行激活(Hydrate)。

## 搭建过程

1. 使用 ts-node 和 nodemon 实现 ts 热更新
2. 构建 koa 服务
3. 构建 vue3+vite 的 SSR 服务
4. 接入pinia和vue-router

## 启动命令

```
安装依赖
npm i 

开发启动
npm run dev

打包构建
npm run build

生产启动
npm run start
```

## TODO

- [x] 引入 pinia
- [x] 引入 vue-router
- [x] koa 处理请求
- [x] 处理打包生产环境
- [x] 预加载

## 请求处理

node 端拿到用户请求，根据路径找到对应页面组件，并且根据请求携带数据渲染首屏

## 请求污染

避免状态单例，每个请求都必须是全新的独立的函数调用，在 main.ts 中 createApp 需要写成函数

## 页面路由

由 vue-router 处理，koa 只需要进入页面 router。客户端使用 WebHistory 模式，服务端需要使用 MemoryHistory 模式，并且手动加入初始路径，确保客户端和用户端解析的路由一致。

## 生产环境构建

为了将 SSR 项目可以在生产环境运行，我们需要：

1. 正常构建生成一个 客户端构建包；
2. 再生成一个 SSR 构建，使其通过 import 直接加载，这样便无需再使用 Vite 的 ssrLoadModule；
3. 修改 package.json 构建命令

## 开发模式首屏闪屏原因

由于开发模式和生产构建包对于样式的引入方式不同，生产模式是以vue文件 .vue?vue&type=style&index=0&scoped=b0f1d2fd&lang.css 的文件引入，首屏拿到html先渲染无CSS的网页，引入vue文件时才会引入对应组件的样式重新渲染成最终的样式。

而生产构建的包以link标签引入一个CSS文件，首屏即可渲染出正确的样式。

## 同构应用

应用的代码在客户端和服务端都会执行，区别仅在于生命周期钩子函数只在浏览器执行，而不在服务器渲染时执行

## 预渲染

预渲染，是另一种流行的构建快速网站的技术。如果用服务端渲染一个页面所需的数据对每个用户来说都是相同的，那么我们可以只渲染一次，提前在构建过程中完成，而不是每次请求进来都重新渲染页面。预渲染的页面生成后作为静态 HTML 文件被服务器托管。

